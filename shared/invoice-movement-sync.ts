/**
 * SERVIZIO SINCRONIZZAZIONE FATTURE → MOVIMENTI
 * Sistema automatico per creare movimenti finanziari da fatture emesse
 * Gestisce tipologie documento, importi negativi e mappature complete
 */

import type { Invoice, Movement, InvoiceType, InsertMovement } from "./schema";

// Tipologie documento che generano importi negativi
const NEGATIVE_AMOUNT_INVOICE_TYPES = [
  'TD04', // Nota di credito
  'TD08', // Nota di credito semplificata  
];

// Tipologie documento che NON generano movimenti automatici
const NON_MOVEMENT_INVOICE_TYPES = [
  'TD20', // Autofattura (già contabilizzata)
  'TD21', // Autofattura per cessione beni (già contabilizzata)
  'TD22', // Estrazione beni da deposito IVA
];

// Mapping codici tipologia documento per determinare causale movimento
const INVOICE_TYPE_TO_MOVEMENT_REASON: Record<string, string> = {
  'TD01': 'FATT_ATT',   // Fattura attiva → Fatturazione attiva
  'TD02': 'FATT_ACC',   // Fattura acconto → Fatturazione acconto
  'TD03': 'FATT_ACC',   // Fattura acconto/saldo → Fatturazione acconto
  'TD04': 'NOTA_CR',    // Nota di credito → Nota credito
  'TD05': 'NOTA_DB',    // Nota di debito → Nota debito
  'TD06': 'FATT_ATT',   // Parcella → Fatturazione attiva
  'TD07': 'FATT_SEMPL', // Fattura semplificata → Fatturazione semplificata
  'TD08': 'NOTA_CR',    // Nota credito semplificata → Nota credito
  'TD09': 'FATT_SEMPL', // Nota di debito semplificata → Nota debito
};

export interface InvoiceMovementSyncOptions {
  /** Forza la creazione anche se esiste già un movimento collegato */
  forceCreate?: boolean;
  /** Core ID specifico da usare (se non specificato usa il default dell'azienda) */
  coreId?: string;
  /** Status ID specifico da usare per il movimento */
  statusId?: string;
  /** Reason ID specifico da usare (se non specificato usa il mapping automatico) */
  reasonId?: string;
  /** Note aggiuntive da aggiungere al movimento */
  additionalNotes?: string;
}

export interface InvoiceMovementMapping {
  /** Importo calcolato (positivo o negativo) */
  amount: number;
  /** Tipo movimento (income/expense) */
  movementType: 'income' | 'expense';
  /** ID causale movimento suggerita */
  suggestedReasonId: string;
  /** Note generate automaticamente */
  autoGeneratedNotes: string;
  /** Indica se è un documento che genera importo negativo */
  isNegativeAmount: boolean;
  /** Indica se è un documento che non dovrebbe generare movimento */
  shouldSkipMovement: boolean;
}

/**
 * Analizza una fattura e determina come mappare i dati per il movimento
 */
export function analyzeInvoiceForMovement(
  invoice: Invoice & { invoiceType: InvoiceType },
  invoiceLines?: any[]
): InvoiceMovementMapping {
  const isNegativeType = NEGATIVE_AMOUNT_INVOICE_TYPES.includes(invoice.invoiceType.code);
  const shouldSkip = NON_MOVEMENT_INVOICE_TYPES.includes(invoice.invoiceType.code);
  
  // Calcola importo base
  const baseAmount = parseFloat(invoice.totalAmount.toString());
  const finalAmount = isNegativeType ? -baseAmount : baseAmount;
  
  // Determina tipo movimento basato su direzione fattura
  let movementType: 'income' | 'expense';
  if (invoice.direction === 'outgoing') {
    // Fattura emessa → sempre entrata (anche se negativa per note credito)
    movementType = 'income';
  } else {
    // Fattura ricevuta → sempre uscita
    movementType = 'expense';
  }
  
  // Genera note automatiche
  const autoNotes = generateAutoNotes(invoice, isNegativeType);
  
  // Suggerisci causale
  const suggestedReasonId = INVOICE_TYPE_TO_MOVEMENT_REASON[invoice.invoiceType.code] || 'FATT_ATT';
  
  return {
    amount: finalAmount,
    movementType,
    suggestedReasonId,
    autoGeneratedNotes: autoNotes,
    isNegativeAmount: isNegativeType,
    shouldSkipMovement: shouldSkip
  };
}

/**
 * Genera note automatiche per il movimento basate sulla fattura
 */
function generateAutoNotes(invoice: Invoice, isNegativeAmount: boolean): string {
  const notes = [];
  
  // Tipo documento
  const docType = isNegativeAmount ? 'Nota di credito' : 'Fattura';
  notes.push(`${docType} n. ${invoice.number}/${invoice.year}`);
  
  // Serie se presente
  if (invoice.series) {
    notes.push(`Serie: ${invoice.series}`);
  }
  
  // Data emissione
  notes.push(`Data emissione: ${invoice.issueDate}`);
  
  // Cliente/Fornitore
  if (invoice.direction === 'outgoing' && invoice.customerId) {
    notes.push('Cliente: [Auto-collegato]');
  } else if (invoice.direction === 'incoming' && invoice.supplierId) {
    notes.push('Fornitore: [Auto-collegato]');
  }
  
  // Stato SDI se rilevante
  if (invoice.sdiStatus && invoice.sdiStatus !== 'draft') {
    const sdiStatusMap: Record<string, string> = {
      'sent': 'Inviata al SDI',
      'accepted': 'Accettata dal SDI',
      'rejected': 'Rifiutata dal SDI',
      'error': 'Errore SDI'
    };
    notes.push(`SDI: ${sdiStatusMap[invoice.sdiStatus] || invoice.sdiStatus}`);
  }
  
  return notes.join(' | ');
}

/**
 * Crea i dati per un nuovo movimento basato su una fattura
 */
export function createMovementDataFromInvoice(
  invoice: Invoice & { invoiceType: InvoiceType },
  mapping: InvoiceMovementMapping,
  options: InvoiceMovementSyncOptions = {}
): InsertMovement {
  // Dati base movimento
  const movementData: InsertMovement = {
    // Date
    insertDate: new Date().toISOString().split('T')[0], // Oggi
    flowDate: invoice.issueDate, // Data fattura
    
    // Tipo e importi
    type: mapping.movementType,
    amount: Math.abs(mapping.amount).toString(), // Sempre positivo nel campo amount
    vatAmount: invoice.totalTaxAmount.toString(),
    netAmount: invoice.totalTaxableAmount.toString(),
    
    // Relazioni obbligatorie
    companyId: invoice.companyId,
    coreId: options.coreId || '', // Deve essere fornito dall'esterno
    statusId: options.statusId || '', // Deve essere fornito dall'esterno
    reasonId: options.reasonId || mapping.suggestedReasonId,
    
    // Cliente/Fornitore
    customerId: invoice.customerId || undefined,
    supplierId: invoice.supplierId || undefined,
    
    // Metadati fattura
    invoiceNumber: `${invoice.number}/${invoice.year}`,
    documentNumber: `${invoice.invoiceType.code}-${invoice.number}`,
    xmlData: invoice.xmlContent || undefined,
    
    // Note
    notes: [
      mapping.autoGeneratedNotes,
      invoice.notes,
      options.additionalNotes
    ].filter(Boolean).join('\n\n'),
  };
  
  // Se è un importo negativo (nota credito), aggiungi segno negativo all'amount
  if (mapping.isNegativeAmount) {
    movementData.amount = (-Math.abs(mapping.amount)).toString();
  }
  
  return movementData;
}

/**
 * Valida se una fattura può generare un movimento
 */
export function validateInvoiceForMovement(
  invoice: Invoice & { invoiceType: InvoiceType }
): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Controlli base
  if (!invoice.companyId) {
    errors.push('Azienda mancante');
  }
  
  if (!invoice.totalAmount || parseFloat(invoice.totalAmount.toString()) === 0) {
    errors.push('Importo fattura non valido');
  }
  
  if (!invoice.issueDate) {
    errors.push('Data emissione mancante');
  }
  
  // Controllo direzione e cliente/fornitore
  if (invoice.direction === 'outgoing' && !invoice.customerId) {
    errors.push('Cliente mancante per fattura emessa');
  }
  
  if (invoice.direction === 'incoming' && !invoice.supplierId) {
    errors.push('Fornitore mancante per fattura ricevuta');
  }
  
  // Controllo stato fattura
  if (invoice.status === 'cancelled') {
    errors.push('Fattura annullata - movimento non generabile');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Utility per determinare se un movimento esistente è collegato a una fattura
 */
export function isMovementLinkedToInvoice(
  movement: Movement,
  invoice: Invoice
): boolean {
  // Controlla numero fattura
  if (movement.invoiceNumber === `${invoice.number}/${invoice.year}`) {
    return true;
  }
  
  // Controlla documento number
  if (movement.documentNumber?.includes(invoice.number)) {
    return true;
  }
  
  // Controlla XML data
  if (movement.xmlData && invoice.xmlContent && 
      movement.xmlData === invoice.xmlContent) {
    return true;
  }
  
  return false;
}

/**
 * Calcola il VAT Code ID dalla prima riga della fattura
 */
export function extractVatCodeFromInvoice(invoiceLines: any[]): string | undefined {
  if (!invoiceLines || invoiceLines.length === 0) {
    return undefined;
  }
  
  // Prende il VAT code dalla prima riga (la più rappresentativa)
  return invoiceLines[0]?.vatCodeId;
}