/**
 * SERVIZIO SINCRONIZZAZIONE FATTURE → MOVIMENTI
 * Sistema automatico per creare movimenti finanziari da fatture emesse
 * Gestisce tipologie documento, importi negativi e mappature complete
 */

import type { Invoice, Movement, InvoiceType, InsertMovement } from "./schema";

// Tipologie documento che generano importi negativi
const NEGATIVE_AMOUNT_INVOICE_TYPES = [
  'TD04', // Nota di credito
  'TD08', // Nota di credito semplificata  
];

// Tipologie documento che NON generano movimenti automatici
const NON_MOVEMENT_INVOICE_TYPES = [
  'TD20', // Autofattura (già contabilizzata)
  'TD21', // Autofattura per cessione beni (già contabilizzata)
  'TD22', // Estrazione beni da deposito IVA
];

// Mapping codici tipologia documento per determinare causale movimento
const INVOICE_TYPE_TO_MOVEMENT_REASON: Record<string, string> = {
  'TD01': 'FATT_ATT',   // Fattura attiva → Fatturazione attiva
  'TD02': 'FATT_ACC',   // Fattura acconto → Fatturazione acconto
  'TD03': 'FATT_ACC',   // Fattura acconto/saldo → Fatturazione acconto
  'TD04': 'NOTA_CR',    // Nota di credito → Nota credito
  'TD05': 'NOTA_DB',    // Nota di debito → Nota debito
  'TD06': 'FATT_ATT',   // Parcella → Fatturazione attiva
  'TD07': 'FATT_SEMPL', // Fattura semplificata → Fatturazione semplificata
  'TD08': 'NOTA_CR',    // Nota credito semplificata → Nota credito
  'TD09': 'FATT_SEMPL', // Nota di debito semplificata → Nota debito
};

export interface InvoiceMovementSyncOptions {
  /** Forza la creazione anche se esiste già un movimento collegato */
  forceCreate?: boolean;
  /** Core ID specifico da usare (se non specificato usa il default dell'azienda) */
  coreId?: string;
  /** Status ID specifico da usare per il movimento */
  statusId?: string;
  /** Reason ID specifico da usare (se non specificato usa il mapping automatico) */
  reasonId?: string;
  /** Note aggiuntive da aggiungere al movimento */
  additionalNotes?: string;
}

export interface InvoiceMovementMapping {
  /** Importo calcolato (positivo o negativo) */
  amount: number;
  /** Tipo movimento (income/expense) */
  movementType: 'income' | 'expense';
  /** ID causale movimento suggerita */
  suggestedReasonId: string;
  /** Note generate automaticamente */
  autoGeneratedNotes: string;
  /** Indica se è un documento che genera importo negativo */
  isNegativeAmount: boolean;
  /** Indica se è un documento che non dovrebbe generare movimento */
  shouldSkipMovement: boolean;
}

/**
 * Analizza una fattura e determina come mappare i dati per il movimento
 */
export function analyzeInvoiceForMovement(
  invoice: Invoice & { invoiceType: InvoiceType },
  invoiceLines?: any[]
): InvoiceMovementMapping {
  const isNegativeType = NEGATIVE_AMOUNT_INVOICE_TYPES.includes(invoice.invoiceType.code);
  const shouldSkip = NON_MOVEMENT_INVOICE_TYPES.includes(invoice.invoiceType.code);
  
  // Calcola importo base
  const baseAmount = parseFloat(invoice.totalAmount.toString());
  const finalAmount = isNegativeType ? -baseAmount : baseAmount;
  
  // Determina tipo movimento basato su direzione fattura
  let movementType: 'income' | 'expense';
  if (invoice.direction === 'outgoing') {
    // Fattura emessa → sempre entrata (anche se negativa per note credito)
    movementType = 'income';
  } else {
    // Fattura ricevuta → sempre uscita (spesa)
    movementType = 'expense';
  }
  
  // LOGICA SPECIALE: Per fatture ricevute, l'importo è sempre negativo nel movimento
  if (invoice.direction === 'incoming') {
    // Per fatture ricevute (incoming), il movimento è sempre expense con importo positivo
    // ma rappresenta un'uscita di denaro (spesa verso fornitore)
  }
  
  // Genera note automatiche
  const autoNotes = generateAutoNotes(invoice, isNegativeType);
  
  // Suggerisci causale
  const suggestedReasonId = INVOICE_TYPE_TO_MOVEMENT_REASON[invoice.invoiceType.code] || 'FATT_ATT';
  
  return {
    amount: finalAmount,
    movementType,
    suggestedReasonId,
    autoGeneratedNotes: autoNotes,
    isNegativeAmount: isNegativeType,
    shouldSkipMovement: shouldSkip
  };
}

/**
 * Genera note automatiche per il movimento basate sulla fattura
 */
function generateAutoNotes(invoice: Invoice, isNegativeAmount: boolean): string {
  const notes = [];
  
  // Tipo documento
  const docType = isNegativeAmount ? 'Nota di credito' : 'Fattura';
  notes.push(`${docType} n. ${invoice.number}/${invoice.year}`);
  
  // Serie se presente
  if (invoice.series) {
    notes.push(`Serie: ${invoice.series}`);
  }
  
  // Data emissione
  notes.push(`Data emissione: ${invoice.issueDate}`);
  
  // Cliente/Fornitore
  if (invoice.direction === 'outgoing' && invoice.customerId) {
    notes.push('Cliente: [Auto-collegato]');
  } else if (invoice.direction === 'incoming' && invoice.supplierId) {
    notes.push('Fornitore: [Auto-collegato]');
  }
  
  // Stato SDI se rilevante
  if (invoice.sdiStatus && invoice.sdiStatus !== 'draft') {
    const sdiStatusMap: Record<string, string> = {
      'sent': 'Inviata al SDI',
      'accepted': 'Accettata dal SDI',
      'rejected': 'Rifiutata dal SDI',
      'error': 'Errore SDI'
    };
    notes.push(`SDI: ${sdiStatusMap[invoice.sdiStatus] || invoice.sdiStatus}`);
  }
  
  return notes.join(' | ');
}

/**
 * Calcola la data del movimento basata sui termini di pagamento
 */
export function calculateMovementDateFromPaymentTerms(
  invoiceDate: string,
  paymentTermsDays: number
): string {
  const invoiceDateObj = new Date(invoiceDate);
  const movementDate = new Date(invoiceDateObj);
  movementDate.setDate(movementDate.getDate() + paymentTermsDays);
  return movementDate.toISOString().split('T')[0];
}

/**
 * Mappa il metodo di pagamento della fattura all'IBAN appropriato
 */
export function mapPaymentMethodToIban(
  paymentMethodId: string | null,
  companyIbans: Array<{ id: string; bankName: string; isActive: boolean }>
): string | undefined {
  if (!paymentMethodId || companyIbans.length === 0) {
    return undefined;
  }
  
  // Per ora usa il primo IBAN attivo dell'azienda
  // In futuro si può implementare una logica più sofisticata
  const activeIban = companyIbans.find(iban => iban.isActive);
  return activeIban?.id;
}

/**
 * Determina lo status del movimento basato sullo status della fattura
 */
export function mapInvoiceStatusToMovementStatus(
  invoiceStatus: string,
  statusMappings: Array<{ id: string; name: string }>
): string {
  // Mapping intelligente status fattura → status movimento
  const statusMap: Record<string, string[]> = {
    'draft': ['Da Saldare', 'Pending'],
    'sent': ['In Lavorazione', 'Processing', 'Sent'],
    'paid': ['Saldato', 'Paid', 'Completed'],
    'cancelled': ['Annullato', 'Cancelled'],
    'overdue': ['Scaduto', 'Overdue']
  };
  
  const targetNames = statusMap[invoiceStatus] || ['Da Saldare'];
  
  // Trova il primo status che corrisponde
  for (const targetName of targetNames) {
    const foundStatus = statusMappings.find(s => 
      s.name.toLowerCase().includes(targetName.toLowerCase())
    );
    if (foundStatus) {
      return foundStatus.id;
    }
  }
  
  // Fallback al primo status disponibile
  return statusMappings[0]?.id || '';
}

/**
 * Crea i dati per un nuovo movimento basato su una fattura con logica avanzata
 */
export function createMovementDataFromInvoice(
  invoice: Invoice & { invoiceType: InvoiceType },
  mapping: InvoiceMovementMapping,
  options: InvoiceMovementSyncOptions & {
    paymentTermsDays?: number;
    companyIbans?: Array<{ id: string; bankName: string; isActive: boolean }>;
    statusMappings?: Array<{ id: string; name: string }>;
  } = {}
): InsertMovement {
  // Calcola data movimento con termini di pagamento
  const flowDate = options.paymentTermsDays !== undefined 
    ? calculateMovementDateFromPaymentTerms(invoice.issueDate, options.paymentTermsDays)
    : invoice.issueDate;
  
  // Mappa IBAN dal metodo di pagamento
  const ibanId = options.companyIbans 
    ? mapPaymentMethodToIban(invoice.paymentMethodId, options.companyIbans)
    : undefined;
  
  // Determina status movimento da status fattura
  const statusId = options.statusMappings
    ? mapInvoiceStatusToMovementStatus(invoice.status, options.statusMappings)
    : options.statusId || '';
  
  // Dati base movimento
  const movementData: InsertMovement = {
    // Date intelligenti
    insertDate: new Date().toISOString().split('T')[0], // Oggi
    flowDate: flowDate, // Calcolata con termini pagamento
    
    // Tipo e importi
    type: mapping.movementType,
    amount: Math.abs(mapping.amount).toString(), // Sempre positivo nel campo amount
    vatAmount: invoice.totalTaxAmount?.toString() || '0',
    netAmount: invoice.totalTaxableAmount?.toString() || '0',
    
    // Relazioni obbligatorie
    companyId: invoice.companyId,
    coreId: options.coreId || '', // Deve essere fornito dall'esterno
    statusId: statusId,
    reasonId: options.reasonId || mapping.suggestedReasonId,
    
    // Cliente/Fornitore
    customerId: invoice.customerId || undefined,
    supplierId: invoice.supplierId || undefined,
    
    // IBAN mappato dal metodo di pagamento
    ibanId: ibanId,
    
    // Metadati fattura
    invoiceNumber: `${invoice.number}/${invoice.year}`,
    documentNumber: `${invoice.invoiceType.code}-${invoice.number}`,
    xmlData: invoice.xmlContent || undefined,
    
    // Note con informazioni sui termini di pagamento
    notes: [
      mapping.autoGeneratedNotes,
      options.paymentTermsDays ? `Termini pagamento: ${options.paymentTermsDays} giorni` : '',
      invoice.notes,
      options.additionalNotes
    ].filter(Boolean).join('\n\n'),
  };
  
  // Se è un importo negativo (nota credito), aggiungi segno negativo all'amount
  if (mapping.isNegativeAmount) {
    movementData.amount = (-Math.abs(mapping.amount)).toString();
  }
  
  return movementData;
}

/**
 * Valida se una fattura può generare un movimento
 */
export function validateInvoiceForMovement(
  invoice: Invoice & { invoiceType: InvoiceType }
): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Controlli base
  if (!invoice.companyId) {
    errors.push('Azienda mancante');
  }
  
  if (!invoice.totalAmount || parseFloat(invoice.totalAmount.toString()) === 0) {
    errors.push('Importo fattura non valido');
  }
  
  if (!invoice.issueDate) {
    errors.push('Data emissione mancante');
  }
  
  // Controllo direzione e cliente/fornitore
  if (invoice.direction === 'outgoing' && !invoice.customerId) {
    errors.push('Cliente mancante per fattura emessa');
  }
  
  if (invoice.direction === 'incoming' && !invoice.supplierId) {
    errors.push('Fornitore mancante per fattura ricevuta');
  }
  
  // Controllo stato fattura
  if (invoice.status === 'cancelled') {
    errors.push('Fattura annullata - movimento non generabile');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Utility per determinare se un movimento esistente è collegato a una fattura
 */
export function isMovementLinkedToInvoice(
  movement: Movement,
  invoice: Invoice
): boolean {
  // Controlla numero fattura
  if (movement.invoiceNumber === `${invoice.number}/${invoice.year}`) {
    return true;
  }
  
  // Controlla documento number
  if (movement.documentNumber?.includes(invoice.number)) {
    return true;
  }
  
  // Controlla XML data
  if (movement.xmlData && invoice.xmlContent && 
      movement.xmlData === invoice.xmlContent) {
    return true;
  }
  
  return false;
}

/**
 * Sincronizzazione bidirezionale: aggiorna movimento quando cambia status fattura
 */
export function syncMovementStatusFromInvoice(
  invoice: Invoice,
  movement: Movement,
  statusMappings: Array<{ id: string; name: string }>
): Partial<Movement> | null {
  const newStatusId = mapInvoiceStatusToMovementStatus(invoice.status, statusMappings);
  
  // Se lo status è già corretto, non serve aggiornare
  if (movement.statusId === newStatusId) {
    return null;
  }
  
  // Aggiorna anche la data di verifica se la fattura è stata pagata
  const updates: Partial<Movement> = {
    statusId: newStatusId
  };
  
  if (invoice.status === 'paid' && invoice.paymentDate) {
    updates.lastVerificationDate = new Date();
    updates.isVerified = true;
    updates.verificationStatus = 'verified';
  }
  
  return updates;
}

/**
 * Trova movimenti collegati a una fattura specifica
 */
export function findLinkedMovements(
  movements: Movement[],
  invoice: Invoice
): Movement[] {
  return movements.filter(movement => 
    isMovementLinkedToInvoice(movement, invoice)
  );
}

/**
 * Calcola il VAT Code ID dalla prima riga della fattura
 */
export function extractVatCodeFromInvoice(invoiceLines: any[]): string | undefined {
  if (!invoiceLines || invoiceLines.length === 0) {
    return undefined;
  }
  
  // Prende il VAT code dalla prima riga (la più rappresentativa)
  return invoiceLines[0]?.vatCodeId;
}